Object.is(a,b)  判断a是否是b
Object.assign(obj1,obj2)  合并对象，只是浅拷贝
let des=Object.getOwnPropertyDescriptor(source,key);  获取对象的属性描述
Object.defineProperty(target,key,value); 设置对象的属性
[].concat(arr1,arr2,arr3)  合并几个数组
switch语句必须带有default分支
obj.hasOwnProperty()  永远不会去查找原型
var arr=['1'];
arr[arr.length]='2';
arr.length=1;
console.log(arr[arr.length]);  
html5新特性：1、语义化；2、本地存储性；3、设备访问性；4、连接特性（WebSockets）；
	     5、网页多媒体特性；6、三维与图形与特效（SVG、Canvas、CSS3）；7、性能与集成特性
APP CHACHE浏览器缓存 <html manifest='index.manifest'>
文件清单
CACHE MANIFEST
CACHE:
theme.css
logo.gif
main.js

NETWORK:
login.asp

FALLBACK:
/html5/ /404.html

AMD --> RequireJS   
define(['./a','./b'],function(){// 依赖必须一开始就写好
 a.doSomething()
 // 此处略去 100 行
 b.doSomething()
 ...
})

CDM --> SeaJS
define(function(require,exports,module){
 var a=require('./a');
 a.doSomething();
 // 此处略去 100 行
 var b=require('./b');
 b.doSomething();
 ...
})

‘1’-‘1’；‘1’-‘1’+‘1’；

'use strict' 测试在严格模式和非严格模式下的输出
(function(x){delete x;return x;})(1)

var food='sushi';
(function(){
  if(typeof food==='undefined'){
    var food='huacai';
    console.log('eat'+food);
  }else{
    console.log('eat'+food);
  }
})()//声明前置

Math.ceil(7/2);Math.floor(7/2);Math.round(7/2);(7/2).toFixed(0);

CORS是W3c工作草案，它定义了在跨域访问资源时浏览器和服务器之间如何通信。CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。
JSONP与CORS对比
都能解决 Ajax直接请求普通文件存在跨域无权限访问的问题
1、JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求
2、使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理
3、JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS

WEB性能优化
1、减少HTTP请求
减少图片的请求、减少脚本文件与样式表的请求
图片的减少通常有两种方式：css sprites、内联图片、IconFont。
2、页面内部优化
样式表放在顶部、脚本文件放在底部、避免css表达式、把脚本的样式表放在外部、移除重复脚本
3、启用缓存
4、减少下载量--开启gzip压缩
5、优化网络连接
使用CDN加速、减少DNS查找、避免重定向

CSS的单位
px,em,rem,mm,ex,pt,pc,vw,vh

src与href
href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系
src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分

上传（图片）
1)表单上传，form -->enctype="multipart/form-data",type="post";
input -->type="file"
input  -->type="submit"
2)ajax异步无刷新上传，input -->type="file" id="test" name="test",input  -->type="button" 

var formData=new FormData($("#test"));
$.ajax({
	url:"/test.do",
	type:"POST",
	data:formDate,
	processData:false,
	contentType:false,
	success:function(response){

	}
})
3）Flash上传
4）截图粘贴上传
5）拖拽上传

不同浏览器对应的浏览器内核
chrome,firefox,ie9,Opare;webkit,Gecko,Tride,Presto

		function Foo(){
			getName=function(){console.log(1);};
			return this;
		};
		Foo.getName=function(){console.log(2);};
		Foo.prototype.getName=function(){console.log(3);};
		var getName=function(){console.log(4);};
		function getName(){console.log(5);};

		Foo.getName();//2
		getName();//4
		Foo().getName();//1
		getName();//1
		new Foo.getName();//2
		new Foo().getName();//3
		new new Foo().getName();//3
2,4,1,1,2,3,3

onafterpaste 粘贴后出发

拷贝继承，子类继承父类的实例就不会改动父类的原型链上的方法和属性了；
但是子类的实例也还是父类的实例，instanceof方法就知道
function SubType (age){
		SuperType.call(this,name);
		this.age= age;
		this.sayAge = function (){
			alert(this.age);
			}
		}
		(function(){
			var Temp =function (){};
			Temp.prototype=SuperType.prototype;
			Subtype.prototype=new Temp();
		})();

响应式布局与自适应布局：
自适应的目的是在不同分辨率的不同设备上面显示相同的页面。
响应式的概念应该是覆盖了自适应，但是包括的东西更多了。响应式布局可以根据屏幕的大小自动的调整页面的展现方式，以及布局。
<link rel="stylesheet" type="text/css" media="screen and (max-device-width: 400px)" href="tinyScreen.css" />

status 属性可设置或返回窗口状态栏中的文本。
window.status='状态栏信息'

window -- document/history/frames/navigator/location/screen
	  document -- location

null instanceof Object 是false

DOCTYPE标签是一种标准通用标记语言的文档类型声明，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。

var e=Math.pow(2,2);
var s=e-100;
var count=0;
for(var i=s;i<=e;i++){
 count++;
}
console.log(count);

var length=10;
function fn(){
 console.log(this.length);
}
var obj={
 length:5,
 method:function(fn){
  fn();
  arguments[0]();
 }
};
obj.method(fn,1);

javascript是面向对象的.

XHTML与HTML的区别：
XHTML 元素必须被正确地嵌套。
XHTML 元素必须被关闭。
标签名必须用小写字母。
XHTML 文档必须拥有根元素。

CSS3新特性：
1.CSS3的选择器
  1）E:last-child 匹配父元素的最后一个子元素E。
  2）E:nth-child(n)匹配父元素的第n个子元素E。
  3）E:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素E。
2. @Font-face 特性
3. 圆角
4. 多列布局 （multi-column layout）---兼容性不好，还不够成熟。还不能用在实际项目中。
5.阴影（Shadow）
6.CSS3 的渐变效果 
7.css弹性盒子模型
8.CSS3制作特效
  1) Transition 对象变换时的过渡效果
  缩写方式：
  transition:border-color .5s ease-in .1s, background-color .5s ease-in .1s, color .5s ease-in .1s;
  2) Transforms 2D转换效果
  主要包括 translate（水平移动）、rotate（旋转）、scale（伸缩）、skew（倾斜）
  3) Animation动画特效
  
添加元素：
  Document.createElement() // 创建元素
  let element = document.createElement(tagName[, options])

  Document.createTextNode() // 创建一个新的文本节点
  var text = document.createTextNode(data)

  Document.createAttribute() // 创建并返回一个新的属性节点
  attribute = document.createAttribute(name)

  Document.createComment() // 创建并返回一个注释节点
  var commentNode = document.createComment(data)
  
  Document.createDocumentFragment() // 创建一个新的空的文档片段
  var docFragment = document.createDocumentFragment()

  Node.appendChild() // 将一个节点添加到指定父节点的子节点列表末尾
  var child = node.appendChild(child)

  Element.classList.add() // 添加指定的类值class
  elementNodeReference.classList.add( String [, String] )

  Document.write()  
  Document.writeIn() // 将文本字符串写入打开的文档流
  document.write(markup)
  document.writeIn(line)
  document.write()和writeIn()的区别是前者没有换行，而后者有换行。

  Element.removeAttribute() // 从元素中删除指定的属性
  element.removeAttribute(attrName)

  Element.removeChild(）// 删除子元素
  var oldChild = node.removeChild(child);OR element.removeChild(child);

  ChildNode.remove() // 删除元素
  elementNodeReference.remove()

  Child.parentNode.removeChild(child) // 不确定父元素时可这样删除子元素
  if (node.parentNode) {
  //判断node是否在DOM树中
    node.parentNode.removeChild(node);
  }

  Element.classList.remove() // 移除元素中一个或多个类名
  elementNodeReference.classList.remove( String [,String] )

  Node.innerText // 修改元素文本内容
  Node.innerHTML =new content

  Element.innerHTML // 设置或获取描述元素后代的HTML语句
  const content = element.innerHTML;
  // 返回时，内容包含描述所有元素后代的序列化HTML代码。
  element.innerHTML = markup;
  // 除所有元素的子节点，解析内容字符串，并将生成的节点分配给元素的子元素。

  node.cloneNode() // 拷贝元素(包括所有属性和值)
  var dupNode = node.cloneNode(deep)
  <!--example-->
  <body>
  <ul id="myList1">
      <li>iPhone</li>
      <li>iPad</li>
  </ul>
  <ul id="myList2">
      <li>Macbook</li>
      <li>appleMusic</li >
  </ul>
  <button onclick="myFunction()">复制</button>
  <script>
  function myFunction(){
      var itm=document.getElementById("myList2").lastChild;
      var cln=itm.cloneNode(true);
      document.getElementById("myList1").appendChild(cln);
  }
  </script>
  </body>
  <!--点击复制按钮，myList2中最后元素会复制到myList1中-->

  Element.setAttribute() // 设置或者改变指定属性并指定值
  element.setAttribute(name, value)

  style.property = new style // 修改元素CSS属性值
  var title= document.querySelector("h1")
  title.style.backgroundColor = "red" // h1背景色改为红色

  Node.replaceChild() // 替换子节点
  replacedNode = parentNode.replaceChild(newChild, oldChild)

  attribute.getAttribute() // 返回元素的指定属性值
  let attribute = element.getAttribute(attributeName)

  Document.getElementsByClassName() // 返回一个节点列表（数组），包含了所有拥有指定 class 的子元素
  var elements = document.getElementsByClassName(names); // or:
  var elements = rootElement.getElementsByClassName(names);

  Document.getElementsByName() // 返回带有指定名称的对象集合
  elements = document.getElementsByName(name)

  Document.getElementsByTagName() // 返回带有指定标签名的对象集合
  var elements = document.getElementsByTagName(name)

  Document.getElementById() // 返回对拥有指定 id 的第一个对象的引用
  element = document.getElementById(id)

  Document.querySelector() // 返回文档中匹配指定的CSS选择器的第一元素
  element = document.querySelector(selectors) // 语法
  //example
  document.querySelector("#demo") // 获取文档中ID为demo的元素

  Document.querySelectorAll() // 返回与指定的选择器组匹配的文档中的元素列表
  elementList = document.querySelectorAll(selectors)

function test(a){
  argument[0]=2;
  console.log(a);
}
test();//undefine

